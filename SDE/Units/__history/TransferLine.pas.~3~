unit TransferLine;

interface

uses
  SysUtils, Classes, Controls, ExtCtrls, Forms, Line, Alternative, Point,
  QEditMod, SyntUnit, QSyntSymbol, Variable;

type
  TTransferLine = class(TComponent)
  public
    Prev: TLine;
    Next: TLine;
    Depth: Integer;
    constructor Create(Sender: TLine); override;
    procedure TransferLineAlign();
    procedure TransferLineDraw();
    procedure TransferLineListSet(Sender : TLine);
    function CalcHeightTop(): integer;
    function CalcHeightBottom(): integer;
  end;

var
  TrLnElems: array[1..3] of TLine;
 // 1 - Right
 // 2 - Main
 // 3 - Left

implementation

uses
  Main;

//Создание линии перехода
constructor TTransferLine.Create(Sender: TLine);
begin
  TrLnElems[1] := TLine.Create(Form1);
  TrLnElems[1].Parent := Form1;
  TrLnElems[2] := TLine.Create(Form1);
  TrLnElems[2].Parent := Form1;
  TrLnElems[3] := TLine.Create(Form1);
  TrLnElems[3].Parent := Form1;

  TransferLineListSet(Sender);
  TransferLineAlign();
  TransferLineDraw();
end;

procedure TTransferLine.TransferLineListSet(Line_1, Line_2 : TLine);
begin
  Self.Prev := hui;
  Self.Next := Line_2;
end;

//Alignment
procedure TTransferLine.TransferLineAlign();
var
  i: Integer;
begin
  TrLnElems[1].Width := LnH;
  TrLnElems[1].Height := CalcHeightTop();
  TrLnElems[1].Left := Prev.Width + Prev.Left;
  TrLnElems[1].Top := Prev.Top;
  TrLnElems[3].Width := LnH;
  TrLnElems[3].Height := CalcHeightBottom();
  TrLnElems[3].Left := LeftBorder;
  TrLnElems[3].Top := TrLnElems[1].Top + TrLnElems[1].Height - LnH;
  TrLnElems[2].Width := TrLnElems[3].Left + LnH - TrLnElems[1].Left;
  TrLnElems[2].Height := LnH;
  TrLnElems[2].Left := TrLnElems[3].Left + TrLnElems[3].Width;
  TrLnElems[2].Top := TrLnElems[3].Top;

  Form1.ObjectsAlign(Depth + 1, true);
end;

//Рисование линии
procedure TTransferLine.TransferLineDraw();
begin
  TrLnElems[1].Repaint;
  TrLnElems[1].Canvas.Pen.Width := 2;
  TrLnElems[2].Repaint;
  TrLnElems[2].Canvas.Pen.Width := 2;
  TrLnElems[3].Repaint;
  TrLnElems[3].Canvas.Pen.Width := 2;
  TrLnElems[1].Canvas.Rectangle(0, LnH div 2, TrLnElems[1].Canvas.Pen.Width - 1, TrLnElems[1].Height - (LnH div 2));
  TrLnElems[2].Canvas.Rectangle(0, LnH div 2, TrLnElems[2].Width, (LnH div 2) + (TrLnElems[2].Canvas.Pen.Width - 1));
  TrLnElems[3].Canvas.Rectangle(TrLnElems[3].Width, LnH div 2, TrLnElems[3].Width - 1, TrLnElems[3].Height - (LnH div 2));
  TrLnElems[2].Canvas.MoveTo(TrLnElems[2].Width div 2, TrLnElems[2].Height div 2);
  TrLnElems[2].Canvas.LineTo(TrLnElems[2].Width div 2 + TrLnElems[2].Height div 4 + 8, TrLnElems[2].Height div 4);
  TrLnElems[2].Canvas.MoveTo(TrLnElems[2].Width div 2, TrLnElems[2].Height div 2);
  TrLnElems[2].Canvas.LineTo(TrLnElems[2].Width div 2 + TrLnElems[2].Height div 4 + 8, TrLnElems[2].Height - TrLnElems[2].Height div 4);
end;

function TTransferLine.CalcHeightTop(): integer;
var
  i: Integer;
  obj: TComponent;
  Ln: TLine;
  Alt: TAlternative;
begin
  Result := 0;
  Ln := Prev;
  while (Ln <> nil) do
  begin
    for i := 0 to Length(Ln.alternative) - 1 do
    begin
      Alt := (Ln.alternative[i] as TAlternative);
      if ((Alt.Height + Alt.Top) > Result) and (not Alt.isUpper) then
        Result := Alt.Height + Alt.Top
    end;
    if (Ln.Prev is TSyntSymbol) then
      Ln := (Ln.Prev as TSyntSymbol).Prev as TLine
    else
      Ln := nil;
  end;
end;

function TTransferLine.CalcHeightBottom(): integer;
var
  i: Integer;
  obj: TComponent;
  Ln: TLine;
  Alt: TAlternative;
begin
  Result := 0;
  Ln := Next;
  while (Ln <> nil) do
  begin
    for i := 0 to Length(Ln.alternative) - 1 do
    begin
      Alt := (Ln.alternative[i] as TAlternative);
      if ((Alt.Height + Alt.Top) > Result) and (Alt.isUpper) then
        Result := Alt.Height + Alt.Top
    end;
    if (Ln.Next is TSyntSymbol) then
      Ln := (Ln.Next as TSyntSymbol).Next as TLine
    else
      Ln := nil;
  end;
end;

end.

