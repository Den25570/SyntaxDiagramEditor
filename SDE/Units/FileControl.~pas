unit FileControl;

interface

implementation

end.

{procedure TStates.SaveProgramState();
var
 i : Integer;
begin
   if Pstates_head = nil then
      New(Pstates_head);
   for i := 0 to Form1.ComponentCount-1 do
   begin
      if Form1.Components[i] is TLine then
      begin
        SetLength(Pstates_head^.Lines, Length(Pstates_head^.Lines)+1);
        Pstates_head^.Lines[Length(Pstates_head^.Lines)-1] := Form1.Components[i] as TLine;
      end
      else if Form1.Components[i] is TAlternative then
      begin
        SetLength(Pstates_head^.Alternatives, Length(Pstates_head^.Alternatives)+1);
        Pstates_head^.Alternatives[Length(Pstates_head^.Alternatives)-1] := Form1.Components[i] as TAlternative;
      end
      else if Form1.Components[i] is TVariable then
      begin
        SetLength(Pstates_head^.Variables, Length(Pstates_head^.Variables)+1);
        Pstates_head^.Variables[Length(Pstates_head^.Variables)-1] := Form1.Components[i] as TVariable;
      end
      else if Form1.Components[i] is TConstant then
      begin
        SetLength(Pstates_head^.Constants, Length(Pstates_head^.Constants)+1);
        Pstates_head^.Constants[Length(Pstates_head^.Constants)-1] := Form1.Components[i] as TConstant;
      end
      else if Form1.Components[i] is TTransferLine then
      begin
        SetLength(Pstates_head^.TrLines, Length(Pstates_head^.TrLines)+1);
        Pstates_head^.TrLines[Length(Pstates_head^.TrLines)-1] := Form1.Components[i] as TTransferLine;
      end
   end;
end;     }

